<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Example Page</title>
    <link rel="stylesheet" href="semantic.min.css">
    <link rel="stylesheet" href="default.css">
    <script src="https://unpkg.com/dayjs@1.8.21/dayjs.min.js"></script>
    <script src="https://unpkg.com/dayjs@1.8.21/plugin/relativeTime.js"></script>
    <script>
        dayjs.extend(window.dayjs_plugin_relativeTime)
    </script>
</head>

<body>
    <main id="servers-container">
        <pre class="json-file-preview" style="display:none;"></pre>
        <ul class="servers-list"></ul>
        <div id="detail-info-modal" class="ui page dimmer"></div>
    </main>
    <footer></footer>
</body>
<script>
    // Render functions
    function ServerCardRenderer(server) {
        function computeStatus(val) {
            if (val < 50) return "success";
            if (val < 80 && val >= 50) return "warning";
            if (val >= 80 && val <= 100) return "error";
            return ""
        }
        function computeOsIcon(os) {
            const DebianLogo = '/icos/os-icons/cib-debian.svg';
            const AppleLogo = '/icos/os-icons/cib-apple.svg';
            const ArchLogo = '/icos/os-icons/cib-arch-linux.svg';
            const CentOSLogo = '/icos/os-icons/cib-centos.svg';
            const FedoraLogo = '/icos/os-icons/cib-fedora.svg';
            const GentooLogo = '/icos/os-icons/cib-gentoo.svg';
            const OpenSUSELogo = '/icos/os-icons/cib-opensuse.svg';
            const RedhatLogo = '/icos/os-icons/cib-redhat.svg';
            const UbuntuLogo = '/icos/os-icons/cib-ubuntu.svg';
            const WindowsLogo = '/icos/os-icons/cib-windows.svg';

            const DefaultLogo = '/icos/os-icons/cib-linux.svg';

            const osIconPathMap = {
                "apple": AppleLogo,
                "arch-linux": ArchLogo,
                "centos": CentOSLogo,
                "debian": DebianLogo,
                "fedora": FedoraLogo,
                "gentoo": GentooLogo,
                "opensuse": OpenSUSELogo,
                "redhat": RedhatLogo,
                "ubuntu": UbuntuLogo,
                "windows": WindowsLogo
            }
            return `<i class="os-icon" style="background: url(${osIconPathMap[os.toLowerCase()] || DefaultLogo}) no-repeat center/100%"></i>`
        }

        const serverOs = server._info ? computeOsIcon(server._info.System.Os) : "";
        return `
        <li class="ui card server-card" data-server="${getAgentUrl(server)}">
            ${server.state ? `
            <div class="content">
                <div class="ui progress ${computeStatus(server.state.Percent.CPU)}" data-percent="${server.state.Percent.CPU}">
                  <div class="bar" style="transition-duration: 300ms; width: ${server.state.Percent.CPU}%;">
                    <div class="progress" style="display:${computeStatus(server.state.Percent.CPU) === 'success' ? 'none' : 'block'};">${server.state.Percent.CPU}%</div>
                    </div>
                  <div class="label">
                    <p class="justify-between-label"><span><i class="dashboard icon"></i>CPU Load 1/5/15:</span> <span>${server.state.Load.CPU.load1}/${server.state.Load.CPU.load5}/${server.state.Load.CPU.load15}</span></p>
                  </div>
                </div>
                <div class="ui progress ${computeStatus(server.state.Percent.Mem)}" data-percent="${server.state.Percent.Mem}">
                    <div class="bar" style="transition-duration: 300ms; width: ${server.state.Percent.Mem}%;">
                    <div class="progress" style="display:${computeStatus(server.state.Percent.Mem) === 'success' ? 'none' : 'block'};">${server.state.Percent.Mem}%</div>
                    </div>
                  <div class="label">
                    <p class="justify-between-label"><span><i class="microchip icon"></i>Memory:</span> <span>${server.state.Load.Mem.Used}/${server.state.Load.Mem.Total}</span></p>
                  </div>
                </div>
                <div class="ui progress ${computeStatus(server.state.Percent.Swap)}" data-percent="${server.state.Percent.Swap}">
                  <div class="bar" style="transition-duration: 300ms; width: ${server.state.Percent.Swap}%;">
                    <div class="progress" style="display:${computeStatus(server.state.Percent.Swap) === 'success' ? 'none' : 'block'};">${server.state.Percent.Swap}%</div>
                    </div>
                  <div class="label">
                    <p class="justify-between-label"><span><i class="disk icon"></i>Swap:</span> <span>${server.state.Load.Swap.Used}/${server.state.Load.Swap.Total}</span></p>
                  </div>
                </div>
                <div class="ui progress ${computeStatus(server.state.Percent.Disk)}" data-percent="${server.state.Percent.Disk}">
                  <div class="bar" style="transition-duration: 300ms; width: ${server.state.Percent.Disk}%;">
                    <div class="progress" style="display:${computeStatus(server.state.Percent.Disk) === 'success' ? 'none' : 'block'};">${server.state.Percent.Disk}%</div>
                    </div>
                  <div class="label">
                    <p class="justify-between-label"><span><i class="disk icon"></i>Disk</span> <span></span></p>
                  </div>
                </div>
            </div>
            ` : ""}
            <div class="content">
                <p class="header justify-between-label">
                    <span><i class="${server.Location} flag"></i>${server.Name}</span>
                    <span>${server._info ? computeOsIcon(server._info.System.Os) : ""}</span>
                </p>
            </div>
            <div class="extra content">
            ${server._info ? `
                <div class="justify-between-label">
                    <p><i class="power off icon"></i> Uptime: ${dayjs(Date.now() - (server.state.Host.Uptime * 1000)).fromNow(true)}</p>
                    <p><i class="docker icon"></i> ${server.state.Container && server.state.Container.length > 0 ? `
                        ${server.state.Container.filter(c => c.State === 'running').length}/${server.state.Container.length}
                    ` : "Disabled"}</p>
                </div>
            `: ""}
                <div>
                    <button class="ui labeled icon button js-show-detail-btn" data-server="${getAgentUrl(server)}">
                      <i class="file alternate outline icon"></i>
                      Detail
                    </button>
                    <button class="ui labeled icon button js-go-terminal-btn" data-connection='${JSON.stringify({ host: server.Host, user: server.User || 'root', port: server.Port })}'>
                      <i class="terminal icon"></i>
                      Connect
                    </button>
                </div>
            </div> 
        </li>
        `
    }

    function ModalRenderer(data) {
        const info = data._info
        const containers = data.state ? (data.state.Container || []) : []
        return `
        <div class="ui active modal">
            <i class="icon close"></i>
            <div class="header">Host: ${data.hostname}</div>
            <div class="content ui two column grid">
                <div class="column" id="detail-info">
                    <h4>Server Detail Infomation:</h4>
                    <p>CPU: ${info.CPU.ModelName} x${info.CPU.Cores}</p>
                    <p>Exposed IP Address: ${info.OuterIPAddr}</p>
                    <p>OS: ${info.System.Os}@${info.System.OsVersion}</p>
                    <p>Arch: ${info.System.Architecture}</p>
                    <p>Virtualization: ${info.System.Virtualization}</p>
                </div>
                ${containers && Array.isArray(containers) && containers.length > 0 ? `
                    <div class="column">
                        <h4>Docker Status at ${dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss')}:</h4>
                        ${containers.map(c => {
                            return `
                                <p class="flex-justify-between">
                                    <span>${c.Name[0].replace("/", "")}</span>
                                    <span style=${c.State === 'running' ? "color: green" : "color: orange"
                                    }>${c.State}</span>
                                </p>
                            `
                         }).join("")}
                    </div>    
                ` : ""}
            </div>
        </div>
        `
    }
</script>
<script>
    // local vars
    // FIXME: remove `loaderBtn`
    let loaderBtn, serversListContainer, modalContainer;
    // global vars
    window.__SERVER_AGENT_UI__ = {
        _config: null,
        get _ui__remember_me() {
            if (!document.querySelector("#configRememberCheckbox")) return false;
            return document.querySelector("#configRememberCheckbox").value === "on"
        },
        servers: [],
        _proxyof_servers: null
    }

    function clearServersList() {
        document.querySelector("#servers-container .servers-list").innerHTML = ""
    }
    function disconnectWSConnections() {
        if (
            !window.__SERVER_AGENT_UI__.servers ||
            !Array.isArray(window.__SERVER_AGENT_UI__.servers) ||
            window.__SERVER_AGENT_UI__.servers.length < 1
        ) return;
        window.__SERVER_AGENT_UI__.servers.forEach(server => {
            if (server.__UPDATE_TIMER__) clearInterval(server.__UPDATE_TIMER__);
            server.socket && server.socket.close && server.socket.close();
        })
    }

    function getAgentUrl(server) {
        if(server.UseProxy) return 'wss://'+window.location.host
        return (server.EnableSSL ? 'wss' : 'ws') + '://' + server.Host + (server.EnableSSL && server.Port === '443' ? "" : ":" + server.Port)
    }
    function getAgentPath(server, token) {
        return server.UseProxy ? '/socket/proxy?host=' + server.Host + '&port=' + server.Port + '&token=' + token : '/socket/server?token=' + token
    }

    function establishWSConnections() {
        if (
            !window.__SERVER_AGENT_UI__._config.servers ||
            !Array.isArray(window.__SERVER_AGENT_UI__._config.servers) ||
            window.__SERVER_AGENT_UI__._config.servers.length < 1
        ) return;
        window.__SERVER_AGENT_UI__.servers = window.__SERVER_AGENT_UI__._config.servers
        window.__SERVER_AGENT_UI__.servers.forEach(server => {
            let socket = new WebSocket(getAgentUrl(server) + getAgentPath(server, window.localStorage.getItem("Server-Agent-Token")));
            server.socket = socket;
            server.socket.onopen = function () {
                server.socket.send("info")
                server.state = {}
                server._proxy_state = new Proxy(server, {
                    set(target, key, value) {
                        if (key === 'state') {
                            target[key] = value;
                            // Update UI via proxied state
                            let _tmp = Object.assign({}, target);
                            delete _tmp._proxy_state;
                            updateServerUI(_tmp);
                        }
                    },
                    get(target, key) {
                        if (key === "agent_url") return (target.enable_ssl && target.port === "443") ? target.host : target.host + target.port
                        return target[key]
                    }
                })
            }
            server.socket.onmessage = function (event) {
                // ignore sent data
                if (event.data === 'info' || event.data === 'state' || event.data === 'ping') return;
                let data;
                try {
                    data = JSON.parse(event.data)
                } catch (e) {
                    console.log("Failed to parse websocket data:");
                    console.log(event.data);
                    throw e;
                }
                switch (data.MessageType) {
                    case "info": {
                        server._info = data;
                        server.__UPDATE_TIMER__ = setInterval(() => {
                            server.socket.send("state");
                        }, 10000)
                        break;
                    }
                    case "state": {
                        server._proxy_state.state = data;
                        break;
                    }
                    case "pong": {
                        console.log("keeping connection...")
                        break;
                    }
                    default: {
                        console.warn("Unrecognized message type:")
                        console.log(event.data)
                    }
                }
            }
            server.socket.onclose = function () {
                console.log("connection lost.");
                disconnectWSConnections();
            }
        })
    }
    function createServersList() {
        let serverFrags = document.createDocumentFragment();
        window.__SERVER_AGENT_UI__.servers.forEach(server => {
            const card = document.createElement('li')
            card.className = 'server-card'
            card.innerHTML = ServerCardRenderer(server)
            serverFrags.appendChild(card);
        })
        document.querySelector("#servers-container .servers-list").append(serverFrags)
    }

    function goTerminalPage(e) {
        if (e.target.classList.contains('js-go-terminal-btn')) {
            let connInfo = e.target.dataset['connection'];
            if (!connInfo) {
                alert("No agent found on the button");
                return;
            }
            connInfo = JSON.parse(connInfo)
            const serverData = window.__SERVER_AGENT_UI__.servers.find(server => (server.Host === connInfo.host && server.Port === connInfo.port))
            if (!serverData) {
                alert("No server found.")
            }
            window.location.href = `/terminal.html?host=${serverData.Host}&port=${serverData.Port}&user=${serverData.User}`
        }
    }
    
    // DOM Event Handlers
    function showDetailModal(e) {
        if (e.target.classList.contains('js-show-detail-btn')) {
            const agentUrl = e.target.dataset['server'];
            if (!agentUrl) {
                alert("No agent found on the button");
                return;
            }
            const serverData = window.__SERVER_AGENT_UI__.servers.find(server => getAgentUrl(server) === agentUrl)
            if (!serverData) {
                alert("No server found.")
            }
            modalContainer.innerHTML = ModalRenderer(serverData);
            modalContainer.classList.add("active");
        }
    }
    function hideDetailModal(e) {
        if (e.target.classList.contains('close') || e.target.classList.contains('dimmer')) {
            modalContainer.classList.remove("active");
            modalContainer.innerHTML = "";
        }
    }
    function updateServerUI(server) {
        let card = document.querySelector(`li.server-card[data-server='${getAgentUrl(server)}']`)
        if (!card) {
            console.log(getAgentUrl(server) + " is not found");
            return;
        }
        card.innerHTML = ServerCardRenderer(server);
    }

    function loadConfig(callback) {
        const trustToken = window.localStorage.getItem("Server-Agent-Token");
        if (!trustToken) {
            window.location.href = "/login.html"
        }
        const loadRequest = new XMLHttpRequest();
        loadRequest.open('GET', '/api/list', true);
        loadRequest.setRequestHeader('Server-Agent-Token', trustToken);
        loadRequest.onload = function () {
            if (this.status === 200) {
                window.__SERVER_AGENT_UI__._config = {
                    servers: JSON.parse(this.response)
                }
                callback && callback();
            } else {
                alert("XHR error");
            }
        }
        loadRequest.onerror = function (e) {
            console.log(e);
        }
        loadRequest.send();
    }

    // Start executing
    document.addEventListener("DOMContentLoaded", function () {
        console.log("loaded")
        // Execute clear
        loadConfig(function () {
            disconnectWSConnections();
            clearServersList();

            // Created cards with observered data
            establishWSConnections();
            createServersList();
        })

        // listener to generated server card
        serversListContainer = document.querySelector("#servers-container .servers-list")
        modalContainer = document.querySelector("#detail-info-modal")
        serversListContainer.addEventListener('click', showDetailModal)
        serversListContainer.addEventListener('click', goTerminalPage)

        // listener to modal
        modalContainer.addEventListener('click', hideDetailModal)
    });

    window.addEventListener('beforeunload', function (e) {
        // Execute clear
        disconnectWSConnections();
        clearServersList();

        if (serversListContainer) {
            serversListContainer.removeEventListener('click', showDetailModal)
            serversListContainer.removeEventListener('click', goTerminalPage)
        }
    })
</script>

</html>